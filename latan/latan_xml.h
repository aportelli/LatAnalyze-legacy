#ifndef LATAN_XML_H_
#define	LATAN_XML_H_

#include <latan/latan_globals.h>
#include <libxml/parser.h>
#include <libxml/tree.h>
#include <libxml/xpath.h>
#include <libxml/xpathInternals.h>

#ifndef LIBXML_XPATH_ENABLED
#error libxml2 was built without XPath interface support
#endif

/* LatAnalyze XML format specification */
#ifndef LATAN_XML_VER
#define LATAN_XML_VER "1.0"
#endif
#ifndef LATAN_XML_ENC
#define LATAN_XML_ENC "UTF-8"
#endif
#ifndef LATAN_XMLNS
#define LATAN_XMLNS "latanalyze/xmlfmt/1.0"
#endif
#ifndef LATAN_XMLNS_PREF
#define LATAN_XMLNS_PREF "latan"
#endif

#define NXML_MARK 10
enum
{
    i_main    = 0,
    i_int     = 1,
    i_double  = 2,
    i_string  = 3,
    i_vect    = 4,
    i_mat     = 5,
    i_row     = 6,
    i_prop    = 7,
    i_rgstate = 8,
    i_sample  = 9
};

extern const strbuf xml_mark[NXML_MARK];

/* libxml2 workspace structure */
typedef struct
{
    xmlDoc *doc;
    xmlNode *node;
    xmlXPathContext* ctxt;
} xml_workspace;

/* elementary tree browsing macros */
#define SKIP_COMMENTS(node)\
{\
    while (strcmp((const char *)(node)->name,"comment") == 0)\
    {\
        node = (node)->next;\
    }\
}

#define GOTO_LAST(node)\
{\
    while ((node)->next != NULL)\
    {\
        node = (node)->next;\
    }\
}

/* namespace/mark test macros */
#define GOT_LATAN_NS(node)\
(((node)->ns) &&\
 (strcmp((const char *)((node)->ns->href),LATAN_XMLNS) == 0) &&\
 (strcmp((const char *)((node)->ns->prefix),LATAN_XMLNS_PREF) == 0))

#define IF_GOT_LATAN_MARK_ELSE_ERROR(node,ind)\
SKIP_COMMENTS(node);\
if (!GOT_LATAN_NS(node))\
{\
    strbuf _errmsg;\
    sprintf(_errmsg,"XML namespace mismatch, expecting xmlns:%s=\"%s\" (%s:%d)",\
            LATAN_XMLNS_PREF,LATAN_XMLNS,(node)->doc->URL,(node)->line);\
    LATAN_ERROR(_errmsg,LATAN_ELATSYN);\
}\
else if (strcmp((const char *)((node)->name),xml_mark[ind]) != 0)\
{\
    strbuf _errmsg;\
    sprintf(_errmsg,"XML mark %s:%s not found (%s:%d)",LATAN_XMLNS_PREF,\
            xml_mark[i_int],(node)->doc->URL,(node)->line);\
    LATAN_ERROR(_errmsg,LATAN_ELATSYN);\
}\
else

/* file I/O macros */
#define BEGIN_XML_PARSING(ws,fname)\
{\
    MALLOC(ws,xml_workspace *,1);\
    (ws)->doc  = NULL;\
    (ws)->node = NULL;\
    (ws)->ctxt = NULL;\
    LIBXML_TEST_VERSION\
    (ws)->doc = xmlReadFile(fname,NULL,XML_PARSE_NOBLANKS|XML_PARSE_NONET);\
    if ((ws)->doc == NULL)\
    {\
        strbuf _errmsg;\
        sprintf(_errmsg,"impossible to parse file %s",fname);\
        LATAN_ERROR(_errmsg,LATAN_EFAULT);\
    }\
    (ws)->ctxt = xmlXPathNewContext((ws)->doc);\
    if ((ws)->ctxt == NULL)\
    {\
        strbuf _errmsg;\
        sprintf(_errmsg,"impossible to create XPath context (%s)",fname);\
        LATAN_ERROR(_errmsg,LATAN_EFAULT);\
    }\
    xmlXPathRegisterNs((ws)->ctxt,(const xmlChar *)LATAN_XMLNS_PREF,\
                       (const xmlChar *)LATAN_XMLNS);\
    (ws)->node = xmlDocGetRootElement((ws)->doc);\
    IF_GOT_LATAN_MARK_ELSE_ERROR((ws)->node,i_main)\
    {\
        (ws)->node = (ws)->node->children;\
    }

#define END_XML_PARSING(ws)\
    xmlFreeDoc((ws)->doc);\
    xmlXPathFreeContext((ws)->ctxt);\
    xmlCleanupParser();\
    (ws)->doc  = NULL;\
    (ws)->node = NULL;\
    (ws)->ctxt = NULL;\
    FREE(ws);\
}

#define BEGIN_XML_WRITING(ws)\
{\
    xmlNs *_ns;\
    strbuf _buf,_ver,_name;\
    MALLOC(ws,xml_workspace *,1);\
    (ws)->doc  = NULL;\
    (ws)->node = NULL;\
    (ws)->ctxt = NULL;\
    LIBXML_TEST_VERSION\
    (ws)->doc  = xmlNewDoc((const xmlChar *)LATAN_XML_VER);\
    _ns        = xmlNewNs((ws)->node,(const xmlChar *)LATAN_XMLNS,\
                          (const xmlChar *)LATAN_XMLNS_PREF);\
    sprintf(_buf,"%s:%s",LATAN_XMLNS_PREF,xml_mark[i_main]);\
    (ws)->node = xmlNewDocNode((ws)->doc,_ns,(const xmlChar *)_buf,\
                               (const xmlChar *)"");\
    xmlDocSetRootElement((ws)->doc,(ws)->node);\
    latan_get_name(_name);\
    latan_get_version(_ver);\
    sprintf(_buf," XML file generated by %s library v%s ",_name,_ver);\
    xmlAddPrevSibling((ws)->node,xmlNewDocComment((ws)->doc,\
                      (const xmlChar *)_buf));\

#define END_XML_WRITING(ws,fname)\
    xmlSaveFormatFileEnc(fname,(ws)->doc,LATAN_XML_ENC,1);\
    xmlFreeNs(_ns);\
    xmlFreeDoc((ws)->doc);\
    (ws)->doc  = NULL;\
    (ws)->node = NULL;\
    (ws)->ctxt = NULL;\
    FREE(ws);\
}

__BEGIN_DECLS

/* data input functions */
latan_errno xml_get_int(int *res, xmlNode *node);
latan_errno xml_get_double(double *res, xmlNode *node);
latan_errno xml_get_string(strbuf res, xmlNode *node);
latan_errno xml_get_vect(mat *v, xmlNode *node);
latan_errno xml_get_vect_size(size_t *row, xmlNode *node);
latan_errno xml_get_mat(mat *m, xmlNode *node);
latan_errno xml_get_mat_size(size_t s[2], xmlNode *node);
latan_errno xml_get_prop(mat *prop, xmlNode *node);
latan_errno xml_get_prop_nt(size_t *nt, xmlNode *node);

/* XPath search function */
xmlXPathObject * xml_get_nodeset(strbuf xpath_expr, xml_workspace *ws);

__END_DECLS

#endif